/**
 * Introduction:
 * 1) Generate the average ATEIs over time within each transect.
 * 2) Extract the pixel with the maximum average ATEI along the center line of each transect. 
 * 3) Divide each transect by the corresponding pixel.
 * 
 * Update: 1/26/2021.
*/

/* Load datasets. */

// Set the work directory.
var wd = "users/treeline/NorthAmerica_GME/";

// Transects with landforms information involved.
var transects = ee.FeatureCollection(wd + 
  "Transects/SelectedHybas4Basins_closedForestsLowerSlopeValley_nonForestedUpperSlope/transectTrend_gte10obs")
  // .limit(1e3);

print(transects.first(), 
  transects.size()) // 469947.

// Annual ATEIs.
var ATEI_1 = ee.Image(wd +
  "Annual_ATEI/ATEI_medianSmdAnlMaxAvgNDVIs_1984to1999");
var ATEI_2 = ee.Image(wd +
  "Annual_ATEI/ATEI_medianSmdAnlMaxAvgNDVIs_2000to2019");

var ATEI = ATEI_1.addBands(ATEI_2);

// print(ATEI.projection().crs(), ATEI.projection().nominalScale())


/* Generate the average ATEIs over time within each transect. */

var avgATEI = ATEI.reduce(ee.Reducer.mean());

// print(avgATEI)


/* Extract the pixel with the maximum average ATEI along the center line of each transect. */

// Buffer threshold for generating a "center-line" polygon.
var centerLineBuffer = -20;

// function extractATEI(transect) {
//   // Get the geometry of the transect.
//   var geom = transect.geometry();
  
//   // Generate a "center-line" polygon of the transect (the result will be void if buffer = -30).
//   var centerLine = geom.buffer(centerLineBuffer);
  
//   // Get the maximum average ATEI along the center line.
//   var maxAvgATEI = avgATEI.reduceRegion({
//     reducer: ee.Reducer.max(), 
//     geometry: centerLine, 
//     scale: 30, 
//     crs: "EPSG:4326", 
//     maxPixels: 1e13
//   }).get("mean");
  
//   return transect.set({
//     maxAvgATEI: maxAvgATEI
//   });
// }

// var ATEIextracted = transects.map(extractATEI);

// // Remove the transects with no ATEI.
// ATEIextracted = ATEIextracted.filter(ee.Filter.neq("maxAvgATEI", null));
// print(ATEIextracted.size(), ATEIextracted.first())


/* Divide each transect by the pixel with the maximum average ATEI. */

// Buffer threshold for generating a circle.
var circleBuffer = 60;

// function extractDivide(transect) {
//   // Get the geometry of the transect.
//   var geom = transect.geometry();
  
//   // Generate a "center-line" polygon of the transect (the result will be void if buffer = -30).
//   var centerLine = geom.buffer(centerLineBuffer);
  
//   // Extract the first centroid of pixels with the maximum average ATEI.
//   var maxAvgATEI = transect.get("maxAvgATEI");
//   var pixels_maxAvgATEI = avgATEI.eq(ee.Number.parse(maxAvgATEI)).selfMask();
  
//   var centroid_maxAvgATEI = pixels_maxAvgATEI.reduceToVectors({
//     geometry: centerLine,
//     maxPixels: 1e13,
//     crs: "EPSG:4326", 
//     scale: 30, 
//     geometryType: "centroid",
//     eightConnected: false // Only pixels that share an edge are considered adjacent.
//   }).first().geometry();
  
//   // Generate a circle around the extracted centroid to extract the intersection points (buffer has to be over 30).
//   var circle = ee.Geometry.LineString(centroid_maxAvgATEI.buffer(circleBuffer).coordinates().get(0));
  
//   // Obtain the perimeter of the transect.
//   var perimeter = ee.Geometry.LineString(geom.coordinates().get(0));
  
//   // Get a convex hull of the intersection points between the circle and the perimeter.
//   var divide = ee.Feature(circle.intersection(perimeter).convexHull());
//   // var divideCoords = divide.coordinates().length();
  
//   return transect.set({
//     divide: divide,
//     // divideCoords: divideCoords
//   });
// }

// var divideExtracted = ATEIextracted.map(extractDivide);

// // Remove the transects with no centroid.
// divideExtracted = divideExtracted.filter(ee.Filter.neq("divide", null));
// print(divideExtracted.size(), divideExtracted.first())

// function divideTransect(transect) {
//   // Get the convex hull of the intersection points between the circle and the perimeter..
//   var divide = transect.get("divide");
  
//   // Divide the transect.
//   var dividedTransect = transect.difference(divide);
  
//   // Get the number of the divided polygons.
//   var plyCount = dividedTransect.geometry().coordinates().length();

//   return dividedTransect.set({
//     plyCount: plyCount
//   });
// }

// var dividedTransects = divideExtracted.map(divideTransect);

// // Remove the undivided transects.
// dividedTransects = dividedTransects.filter(ee.Filter.eq("plyCount", 2));
// print(dividedTransects.size(), dividedTransects.first())

function divideTransect(transect) {
  // Get the geometry of the transect.
  var geom = transect.geometry();
  
  // Generate a "center-line" polygon of the transect (the result will be void if buffer = -30).
  var centerLine = geom.buffer(centerLineBuffer);
    
  // Get the maximum average ATEI along the center line.
  var maxAvgATEI = avgATEI.reduceRegion({
    reducer: ee.Reducer.max(), 
    geometry: centerLine, 
    scale: 30, 
    crs: "EPSG:4326", 
    maxPixels: 1e13
  }).get("mean");
  
  // Extract the first centroid of pixels with the maximum average ATEI.
  var pixels_maxAvgATEI = avgATEI.eq(ee.Number.parse(maxAvgATEI)).selfMask();
  
  var centroid_maxAvgATEI = pixels_maxAvgATEI.reduceToVectors({
    geometry: centerLine,
    maxPixels: 1e13,
    crs: "EPSG:4326", 
    scale: 30, 
    geometryType: "centroid",
    eightConnected: false // Only pixels that share an edge are considered adjacent.
  }).first().geometry();
  
  // Generate a circle around the extracted centroid to extract the intersection points (buffer has to be over 30).
  var circle = ee.Geometry.LineString(centroid_maxAvgATEI.buffer(circleBuffer).coordinates().get(0));
  
  // Obtain the perimeter of the transect.
  var perimeter = ee.Geometry.LineString(geom.coordinates().get(0));
  
  // Get a convex hull of the intersection points between the circle and the perimeter.
  var divide = circle.intersection(perimeter).convexHull();
  
  // Divide the transect.
  var dividedTransect = transect.difference(divide);
  
  // Get the number of the divided polygons.
  var plyCount = dividedTransect.geometry().coordinates().length();

  return dividedTransect.set({
    maxAvgATEI: maxAvgATEI,
    plyCount: plyCount
  });
}

var dividedTransects = transects.map(divideTransect);

// Remove the undivided transects.
dividedTransects = dividedTransects.filter(ee.Filter.eq("plyCount", 2));
print(dividedTransects.first())


// // print(pixels_maxAvgATEI)
Map.setOptions("hybrid");
Map.centerObject(dividedTransects.first(), 12);
Map.addLayer(avgATEI, {min: 0, max: 1, palette: "0000FF, FFFFFF, FF0000"}, "avgATEI");
Map.addLayer(transects, {color: "FFFF00"}, "transects");
Map.addLayer(dividedTransects, {color: "00FF00"}, "dividedTransects");

