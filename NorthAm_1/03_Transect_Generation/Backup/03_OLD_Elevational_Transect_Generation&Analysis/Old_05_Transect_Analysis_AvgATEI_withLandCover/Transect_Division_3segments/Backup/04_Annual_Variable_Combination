/**
 * Introduction:
 * 1) Merge the annual divides with the combined center lines.
 * 
 * Update: 2/16/2021.
 * 
 * Runtime: 1m ~ 26m.
*/


/* Load datasets. */

// Set the work directory.
var wd = "users/treeline/NorthAmerica_GME/";

// Combined center lines.
var combined = ee.FeatureCollection(wd
  + "Transects/SelectedHybas4Basins_closedForestsLowerSlopeValley_nonForestedUpperSlope/"
  + "CenterLines/"
  + "Combined_CenterLines");
// print(combined.first(), combined.size())

// Buffer the center lines.
var bufDist = 45;

var bufferedCL = combined.map(function(CL) {
  return CL.buffer(bufDist);
});

/* Merge the divides with the combined center lines in each year. */

var years = ee.List.sequence(1984, 2019).getInfo();

var filePath = wd
  + "Transects/SelectedHybas4Basins_closedForestsLowerSlopeValley_nonForestedUpperSlope/"
  + "CenterLines/"
  + "AnnualDivides_AnnualATEI_Pt307toPt507/"
  + "AnnualDivides_";

var divides = ee.List(years.map(function(year) {
  // Get the divides in each year.
  var dividesPath = filePath + year;
  var annualDivides = ee.FeatureCollection(dividesPath).map(function(feature) {
    return feature.buffer(bufDist);
  });
  
  return annualDivides.set("Year", year);
}));
// print(divides)


/* Merge the annual divides with the combined center lines. */

// var merged = ee.FeatureCollection(years.map(function(year) {
var merged = ee.FeatureCollection(divides.map(function(annualDivides) {
  // Get the divides in each year.
  // var dividesPath = filePath + year;
  // var annualDivides = ee.FeatureCollection(dividesPath);
  annualDivides = ee.FeatureCollection(annualDivides);
  var year = annualDivides.get("Year");
  
  // Annually merge the divides with each center line.
  var annuallyMerged = combined.map(function(centerLine) {
    // Select the divides intersecting with each center line.
    var intersectedDivides = annualDivides.filterBounds(centerLine.geometry());
    
    // Get the properties of interest.
    var mergedCenterLine = centerLine.set({
      intersectedDivides: intersectedDivides,
      intersectedDividesNo: intersectedDivides.size(), // Number of the intersected divides.
      Year: year
    });
    
    return mergedCenterLine;
  });
  
  // Extract the center lines with one set of intersected divides (two cuts).
  var annuallyMerged_filtered = annuallyMerged.filter(
    ee.Filter.eq("intersectedDividesNo", 1));
  
  // Get the properties of interest from the intersected divides.
  annuallyMerged_filtered = annuallyMerged_filtered.map(function(centerLine) {
    var intersectedDivides = ee.FeatureCollection(centerLine.get("intersectedDivides"));
    
    var propertiesCopied = centerLine.copyProperties({
      source: intersectedDivides.first(), 
      properties: ["ATElen", "divideCount",
        "dvd1Lat", "dvd1Long",
        "dvd2Lat", "dvd2Long",
        "pxCount"]
    });
    
    // Remove the FeatureCollection-type property: intersectedDivides.
    propertiesCopied = ee.Feature(propertiesCopied).select(propertiesCopied.propertyNames()
      .remove("intersectedDivides"));
    
    return ee.Feature(propertiesCopied)//.buffer(bufDist);
  });
  
  return annuallyMerged_filtered;
})).flatten();

// print(merged.first(), merged.size()) // 16941348.
// print(merged.first())

// // Create a filter to define a match as overlapping endpoints.
// var sameEndpoints = ee.Filter.and(
//   ee.Filter.equals({
//     leftField: "maxLat", 
//     rightField: "maxLat"
//   }),
//   ee.Filter.equals({
//     leftField: "maxLong", 
//     rightField: "maxLong"
//   }),
//   ee.Filter.equals({
//     leftField: "minLat", 
//     rightField: "minLat"
//   }),
//   ee.Filter.equals({
//     leftField: "minLong", 
//     rightField: "minLong"
//   })
// );

// // Define the join.
// var saveAllJoin = ee.Join.saveAll({
//   matchesKey: "annualDivides", 
//   ordering: "Year", 
//   ascending: true, 
//   measureKey: "sameEndpoints"
// });

// // Apply the join.
// var joined = saveAllJoin.apply(bufferedCL, merged, sameEndpoints);

// print(joined.first(), joined.size())

// Annually merge the divides with each center line.
var intersectedCLs = bufferedCL.map(function(centerLine) {
  // Select the divides intersecting with the centroid of each center line.
  // var intersectedMerged = ee.FeatureCollection(merged.filterBounds(centerLine.geometry()))
  var intersectedMerged = ee.FeatureCollection(merged.filterBounds(centerLine.geometry().centroid()))
    .toList(36);
  // var intersectedMerged = merged.filterBounds(centerLine.geometry());
  
  // Get the properties of interest.
  var intersectedCenterLine = centerLine.set({
    AnnualATE: intersectedMerged,
    ATEno: intersectedMerged.size(), // Number of the intersected divides.
  });
  
  return intersectedCenterLine;
});

// print(intersectedCLs.first(), intersectedCLs.size())

// Extract the center lines with at least 10 years with divides.
intersectedCLs = intersectedCLs.filter(
  ee.Filter.gte("ATEno", 10));
// print(intersectedCLs.first(), intersectedCLs.size())
print(intersectedCLs.first())

/* Click a transect and get the local information. */

// var clicked = merged.filterBounds(geometry);
// print(clicked.size())

Map.setOptions("hybrid");
Map.setCenter(-113.9881, 48.9362, 13);
Map.addLayer(bufferedCL, {color: "FF0000"}, "Original Transects");
// Map.addLayer(merged, {color: "0000FF"}, "merged", false);

// var empty = ee.Image().byte();

for (var i = 0; i <= 35; i = i + 5) {
  var year = i + 1984;
  var annualATE = ee.FeatureCollection(divides.get(i));
  Map.addLayer(annualATE, {color: "FFFF00"}, "ATE in " + year, true);
  // Map.addLayer(empty.paint(annualATE, 1, 3).randomVisualizer(), {}, "ATE in " + year, true);
}

Map.addLayer(intersectedCLs, {color: "0000FF"}, "ATEs >= 10 yr", false);

