/**
 * Introduction:
 * 1) Group the center lines and perform the following analysis in each group.
 * 2) Extract pixel coordinates around the optimal ATEI threshold along each center line. 
 * 3) Generate a divide at each set of the qualified pixels in each year.
 * 4) Annually select center lines with two divides.
 * 5) Connect each pair of divides with a line string.
 * 
 * Update: 2/16/2021.
 * 
 * Runtime: 31m ~ 3h.
*/


/* Load datasets. */

// Set the work directory.
var wd = "users/treeline/NorthAmerica_GME/";

// Annual ATEIs.
var ATEI_1 = ee.Image(wd +
  "Annual_ATEI/ATEI_medianSmdAnlMaxAvgNDVIs_1984to1999");
var ATEI_2 = ee.Image(wd +
  "Annual_ATEI/ATEI_medianSmdAnlMaxAvgNDVIs_2000to2019");


/* Functions to group center lines. */

function groupCL(index) {
  // Load center lines in each basin.
  var CL = ee.FeatureCollection(wd
    + "Transects/SelectedHybas4Basins_closedForestsLowerSlopeValley_nonForestedUpperSlope/"
    + "CenterLines/"
    + "Basin_" + index);
  
  return CL;
}


/* Create annual masks of ATEI. */

// A target projection system.
var targetPrj = {
  crs: "EPSG:4326", 
  scale: 30
};

// Get the annual ATEIs.
var ATEI = ATEI_1.addBands(ATEI_2)
  .reproject(targetPrj);
// print(ATEI.projection().crs(), ATEI.projection().nominalScale())

// An optimal cut with the highest Youden Index of the validation dataset (over 1000 samples).
var cut = 0.407;
var halfRange = 0.1;

// Create a mask of ATEIs around the optimal cut.
var ATEIdiff = ATEI.subtract(cut).abs();
var ATEImask = ATEIdiff.lte(halfRange);
// print(ATEImask)

// An image of coordinates.
var coords = ee.Image.pixelLonLat()
  .reproject(targetPrj);


// Function to extract divides along each center line.
function extractDivides(CL) {
  // Get the pixels of qualified points.
  var longList = ee.List(CL.get("longitude"));
  var latList = ee.List(CL.get("latitude"));
  
  var longLat = longList.zip(latList);
  
  // Number of the qualified pixels.
  var pxCount = longLat.size();
  
  // Create a polygon (buffered points) around each set of qualified pixels.
  var multiPlg = ee.Geometry.MultiPoint(longLat)
    .buffer(45);
  var plgCoords = multiPlg.coordinates();
  
  // Number of the created polygons (the divides).
  var divideCount = plgCoords.size();
  
  // Set the centroid of each polygon as a divide.
  var ctrs = plgCoords.map(function(coords) {
    var ctr = ee.Geometry.Polygon(coords)
      .centroid();
    
    return ctr;
  });
  
  ctrs = ee.Geometry.MultiPoint(ctrs);
  
  // Copy and set the variables of interest.
  ctrs = ee.Feature(ctrs).copyProperties({
    source: CL, 
    properties: CL.propertyNames()
  }).set({
    pxCount: pxCount,
    divideCount: divideCount
  });
  
  return ctrs;
}

// Function to generate a line string connnecting divides along each center line.
function connectDivides(CL) {
  // Generate a line string between the divides.
  var pts = CL.geometry().coordinates();
  var LS = ee.Geometry.LineString(pts);
  
  // Get the length of the line string.
  var ATElen = LS.length();
  
  // Save the coordinates of divides.
  var divide1 = ee.List(pts.get(0));
  var divide2 = ee.List(pts.get(1));
  
  var dvd1Long = divide1.get(0);
  var dvd1Lat = divide1.get(1);
  
  var dvd2Long = divide2.get(0);
  var dvd2Lat = divide2.get(1);
  
  // Copy and set the variables of interest.
  LS = ee.Feature(LS).copyProperties({
    source: CL, 
    exclude: ["latitude", "longitude"] // List-type properties can not be output to Asset.
  }).set({
    ATElen: ATElen,
    
    dvd1Long: dvd1Long,
    dvd1Lat: dvd1Lat,
    
    dvd2Long: dvd2Long,
    dvd2Lat: dvd2Lat,
  });
  
  return LS;
}


/* Create a list of the index groups of basins. */

// Create a list of indices.
var indices = ee.List.sequence(0, 123);

// Remove the failed task.
indices = indices.remove(106).getInfo();


/* Group and analyze the center lines by indices. */

// Number of basins in each group.
var step = 5;

for (var year = 1984; year <= 2019; year ++) {
  // Extract the qualified pixel coordinates in each year.
  var annualATEImask = ATEImask.select("ATEI_" + year);
  var annuallyMaskedCoords = coords.updateMask(annualATEImask);
  
  
  /* Analyze the first group of transects. */
  
  // Generate the first subset of indices.
  var first_slice = indices.slice(0, 0 + step);
  // print(first_slice)
  
  // Load the center lines in the first group.
  var first_groupedCL = ee.FeatureCollection(first_slice.map(groupCL)).flatten();
  
  // Extract the annual qualified pixel coordinates along each transect in the first group.
  var first_extractedCoords = annuallyMaskedCoords.reduceRegions({
    collection: first_groupedCL, 
    reducer: ee.Reducer.toList(), 
    scale: 30,
    crs: "EPSG:4326"
  });
  
  // Remove center lines with no qualified pixels.
  first_extractedCoords = first_extractedCoords.filter(ee.Filter.and(
    ee.Filter.neq("longitude", []),
    ee.Filter.neq("latitude", [])
  ));
  
  // Extract divides at the qualified pixels along each selected center line.
  var first_extractedDivides = first_extractedCoords.map(extractDivides);
  
  // Select center lines with two divides.
  first_extractedDivides = first_extractedDivides.filter(ee.Filter.equals({
    leftField: "divideCount", 
    rightValue: 2
  }));
  
  // Connect the two divides along each selected center line in the first group.
  var annualDivides = first_extractedDivides.map(connectDivides);
  
  
  /* Analyze the rest groups of transects. */
  
  for (var startIndex = 1; startIndex <= 123; startIndex = startIndex + step) {
    // Generate a subset of indices.
    var endIndex = startIndex + step;
    var indexSlice = indices.slice(startIndex, endIndex);
    // print("indexSlice:", indexSlice)
    
    // Load the center lines in each group.
    var groupedCL = ee.FeatureCollection(indexSlice.map(groupCL)).flatten();
    
    // Extract the annual qualified pixel coordinates along each transect in the group.
    var extractedCoords = annuallyMaskedCoords.reduceRegions({
      collection: groupedCL, 
      reducer: ee.Reducer.toList(), 
      scale: 30,
      crs: "EPSG:4326"
    });
    
    // Remove center lines with no qualified pixels.
    extractedCoords = extractedCoords.filter(ee.Filter.and(
      ee.Filter.neq("longitude", []),
      ee.Filter.neq("latitude", [])
    ));
    
    // Extract divides at the qualified pixels along each selected center line.
    var extractedDivides = extractedCoords.map(extractDivides);
    
    // Select center lines with two divides.
    extractedDivides = extractedDivides.filter(ee.Filter.equals({
      leftField: "divideCount", 
      rightValue: 2
    }));
    
    // Connect the two divides along each selected center line.
    var connectedDivides = extractedDivides.map(connectDivides);
    
    // Merge the result of each group into the feature collection of annual divides.
    annualDivides = annualDivides.merge(connectedDivides);
  }
  // print(year, annualDivides.size())
  
  // Export the annually merged divides to the Asset.
  if (false) {
    var fileName = "AnnualDivides_" + year;
    // print("fileName:", fileName)
    
    Export.table.toAsset({
      collection: annualDivides, 
      description: fileName, 
      assetId: wd + "Transects/SelectedHybas4Basins_closedForestsLowerSlopeValley_nonForestedUpperSlope/"
        + "CenterLines/"
        + "AnnualDivides_AnnualATEI_Pt307toPt507/" 
        + fileName
    });
  }
}


/* Combine and export all the original center lines of transects. */

var centerLines = ee.FeatureCollection(indices.map(groupCL)).flatten();
print(centerLines.size(), // 470593.
  centerLines.first())

if (true) {
  Export.table.toAsset({
    collection: centerLines, 
    description: "Combined_CenterLines", 
    assetId: wd + "Transects/SelectedHybas4Basins_closedForestsLowerSlopeValley_nonForestedUpperSlope/"
      + "CenterLines/"
      + "Combined_CenterLines"
  });
}

