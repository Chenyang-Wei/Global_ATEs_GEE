/**
 * Introduction:
 * 1) Vectorize the segmented CATE.
 * 2) Extract the elevations of the lowest forested lower-slope or valley and 
 *  the highest non-forested upper-slope within each vectorized segment.
 * 3) Select polygons with the two elevational extreme values.
 * 4) Generate a center line of the transect from the highest non-forested upper-slope pixel 
 *  to the lowest forested lower-slope or valley pixel within each selected polygon.
 * 
 * Update: 2/3/2020.
 * 
 * Runtime: 1m ~ 2h.
 * 
 * Failed task: Basin_106 -- Error: Table is empty.
 * Reason: no qualified closed forests and non-forested pixels 
 *  are located within the same CATE segment in the basin.
 */


/* Load datasets. */

// Asset path.
var wdNorthA = "users/treeline/NorthAmerica_GME/";

// Segmented CATE.
var segCATE_raw = ee.Image(wdNorthA + "Transects/" + 
  "90mSegmentedCATE_distToRidgesNoCliff_NAlandformsRemoved_ridgesRemoved");

// HydroSHEDS basins ("hybas_4") with both closed forests on the lower slope or in the valley
//  and non-forested areas on the upper slope.
var basins = ee.FeatureCollection(wdNorthA + "Transects/" + 
  "90mSegmentedCATE_selectedHybas4Basins_closedForestsLowerSlopeValley_nonForestedUpperSlope");

// ALOS elevation (V 2.2).
var elv_raw = ee.Image('JAXA/ALOS/AW3D30/V2_2').select('AVE_DSM');

// Copernicus land cover product.
var landCover_raw = ee.ImageCollection("COPERNICUS/Landcover/100m/Proba-V/Global")
  .select('discrete_classification').first();

// ALOS landforms.
var landforms_raw = ee.Image('CSP/ERGo/1_0/Global/ALOS_landforms').select('constant');


/* Re-project the segmented CATE and the land-cover and landforms datasets to the Landsat projection system. */

var targetPrj = {
    crs: "EPSG:4326",
    scale: 30
  };

var elv_reprj = elv_raw
  .reproject(targetPrj);

var segCATE_reprj = segCATE_raw
  .reproject(targetPrj);

var landCover_reprj = landCover_raw
  .reproject(targetPrj);

var landforms_reprj = landforms_raw
  .reproject(targetPrj);


/* Extract the upper slope, lower slope, and valley. */

// Upper slope.
var upperSlope = landforms_reprj.gte(21).and(landforms_reprj.lte(24))
  .rename("upperSlope");

// print("upperSlope:", 
//   upperSlope.bandTypes(),
//   upperSlope.projection().crs(),
//   upperSlope.projection().nominalScale())

// Lower slope and valley.
var lowerSlope_valley = landforms_reprj.gte(31).and(landforms_reprj.lte(42))
  .rename("lowerSlope_valley");

// print("lowerSlope_valley:", 
//   lowerSlope_valley.bandTypes(),
//   lowerSlope_valley.projection().crs(),
//   lowerSlope_valley.projection().nominalScale())


/* Extract the qualified closed forests and non-forested areas within the segmented CATE. */

// Closed forests on the lower slope or in the valley.
var closedForests = landCover_reprj.gte(111).and(landCover_reprj.lte(116))
  .updateMask(lowerSlope_valley)
  .updateMask(segCATE_reprj)
  .rename("closedForests");

// print("closedForests:", 
//   closedForests.bandTypes(),
//   closedForests.projection().crs(),
//   closedForests.projection().nominalScale())

// Non-forested areas in the Copernicus dataset.
// From "Shrubs" to "Moss and lichen".
var nonForested = landCover_reprj.gte(20).and(landCover_reprj.lte(100))
  .updateMask(upperSlope)
  .updateMask(segCATE_reprj)
  .rename("nonForested");

// print("nonForested:", 
//   nonForested.bandTypes(),
//   nonForested.projection().crs(),
//   nonForested.projection().nominalScale())


/* Combine the segmented CATE with the elevations of the extracted land-cover datasets. */

// Get the ALOS elevation of the extracted land-cover datasets.
var closedForestsElv = elv_reprj.updateMask(closedForests)
  .rename("closedForestsElv");

var nonForestedElv = elv_reprj.updateMask(nonForested)
  .rename("nonForestedElv");

// Combine the segmented CATE with the elevations of the qualified land-cover pixels
// for further extracting the elevational extremes within each vectorized CATE segment.
var segCATEelv = segCATE_reprj
  .addBands(closedForestsElv)
  .addBands(nonForestedElv);

// print("segCATEelv:", 
//   segCATEelv.bandTypes(),
//   segCATEelv.projection().crs(),
//   segCATEelv.projection().nominalScale())


/* Convert the selected HydroSHEDS basins to a list. */

var basinNum = basins.size();

var basinList = basins.toList({
  count: basinNum
});

// print("HydroSHEDS basins:", basinNum, basinList) // 124.


/* Determine the pixel coordinates of the segmented CATE in the ALOS elevation projection system. */

var coords = ee.Image.pixelLonLat()
  .reproject(targetPrj)
  .updateMask(segCATE_reprj);

// print("Coordinate dataset projection:", 
//   coords.bandTypes(),
//   coords.projection().crs(), 
//   coords.projection().nominalScale())


/* Define a function for generating and buffering elevational transects. */

var generateBufferedTransects = function(feature) {  
  // Get the geometry of each selected polygon.
  var geom = feature.geometry();
  
  // Extract the coordinates of pixels with the maximum non-forest elevation.
  var elvMax = feature.get("nonForestedElv_max");
  var maxCoords = coords.updateMask(segCATEelv.select("nonForestedElv")
    .eq(ee.Number.parse(elvMax)))
    .select(["latitude", "longitude"], ["maxLat", "maxLong"]);
  
  // Extract the coordinates of pixels with the minimum forest elevation.
  var elvMin = feature.get("closedForestsElv_min");
  var minCoords = coords.updateMask(segCATEelv.select("closedForestsElv")
    .eq(ee.Number.parse(elvMin)))
    .select(["latitude", "longitude"], ["minLat", "minLong"]);
  
  // Convert the extracted coordinates within the geometry to lists.
  var maxMin_coordLists = maxCoords.addBands(minCoords).reduceRegion({
    reducer: ee.Reducer.toList(),
    geometry: geom,
    crs: "EPSG:4326",
    scale: 30,
    maxPixels: 1e13
  });
  
  // Choose only the coordinates of the first highest/lowest qualified pixel.
  var maxLong = ee.List(maxMin_coordLists.get('maxLong')).get(0);
  var minLong = ee.List(maxMin_coordLists.get('minLong')).get(0);
  
  var maxLat = ee.List(maxMin_coordLists.get('maxLat')).get(0);
  var minLat = ee.List(maxMin_coordLists.get('minLat')).get(0);
  
  // Merge the coordinates of the two pixels into a list of two-element (longitude and latitude) lists.
  var longList = ee.List([maxLong, minLong]);
  var latList = ee.List([maxLat, minLat]);
  
  var coordList = longList.zip(latList);
  
  // Construct a line string between the two pixels based on the merged coordinate list.
  var lineString = ee.Algorithms.GeometryConstructors.LineString(coordList);
  
  // Get the length of the generated line string.
  var lsLength = lineString.length(); // In meters.
  
  // Add the length property to the line string.
  var transect = ee.Feature(lineString).set("totalLen", lsLength);
  
  transect = transect.set({
    minLong: minLong,
    minLat: minLat,
    maxLong: maxLong,
    maxLat: maxLat
  });
  
  // // Create a 30-m buffer for the line string.
  // var buffered = transect.buffer(30); // If no projection is specified, the unit is meters.
  
  return transect;
};


/* Generate and export buffered elevational transects by basins. */

// print(basinNum)

for (var index = 0; index < 124; index ++) {
// for (var index = 0; index < basinNum.getInfo(); index ++) {
// for (var index = 0; index < 1; index ++) { // Testing.
  
  // Extract the geometry of each basin feature.
  var basinFeature = ee.Feature(basinList.get(index));
  var basinGeom = basinFeature.geometry();
  
  // Vectorize the segmented CATE in the basin
  // and extract the elevational extremes within each vectorized polygon.
  var polygonElvMinMax = segCATEelv.reduceToVectors({
    // The first band ("Segmented") of the input image is expected to be an integer type; 
    // adjacent pixels will be in the same segment if they have the same value in this band.
    reducer: ee.Reducer.minMax(), 
    // Extract the elevational extremes.
    // The inputs of this reducer will be taken from the image's bands ("closedForestsElv" and "nonForestedElv") 
    // after dropping the first band ("Segmented"). 
    geometry: basinGeom,
    maxPixels: 1e13,
    crs: "EPSG:4326",
    scale: 30,
    geometryType: "polygon",
    eightConnected: false // Only pixels that share an edge are considered adjacent.
  });
  
  // // Testing.
  // print("polygonElvMinMax:", 
  //   polygonElvMinMax.first(), polygonElvMinMax.size())
  
  // Select polygons with both the min. forest elevation and the max. non-forest elevation.
  // The max. non-forest elevation should be higher than the min. forest elevation.
  var selectedPolygons = polygonElvMinMax.filter(ee.Filter.and(
    ee.Filter.neq("nonForestedElv_max", null),
    ee.Filter.neq("closedForestsElv_min", null),
    ee.Filter.greaterThan({
      leftField: "nonForestedElv_max", 
      rightField: "closedForestsElv_min"
    })));

  // // Testing.
  // print("selectedPolygons:", 
  //   selectedPolygons.first(), selectedPolygons.size())
  
  // Generate and buffer an elevational transect within each selected polygon.
  var bufferedTransects = ee.FeatureCollection(selectedPolygons
    .map(generateBufferedTransects));
  
  // // Testing.
  // print("bufferedTransects:", 
  //   bufferedTransects.first(), bufferedTransects.size())
  
  if (false) { // Testing.
  
    /* Visualization. */
    
    var elvPalette = ['006600', '002200', 'fff700', 'ab7634', 'c4d0ff', 'ffffff'];
    var elvVis = {min: 1000, max: 3500, palette: elvPalette};
    
    // Map.setCenter(-113.7571, 48.829, 10);
    Map.centerObject(bufferedTransects.first(), 16);
    Map.setOptions("hybrid");
    
    Map.addLayer(basins, {color: "FFFF00"}, "basins", true);
    Map.addLayer(segCATE_reprj, {palette: "0000FF"}, "segCATE_reprj", true);
    
    Map.addLayer(coords.select("longitude"), {palette: "FF00FF"}, "longitude", true);
    
    Map.addLayer(selectedPolygons, {color: "00FF00"}, "selectedPolygons", true);
    Map.addLayer(closedForestsElv, elvVis, "closedForestsElv", true);
    Map.addLayer(nonForestedElv, elvVis, "nonForestedElv", true);
    
    Map.addLayer(bufferedTransects, {color: "FF0000"}, "bufferedTransects", true);
  }
  
  else if (true) {
    /* Output the result.*/
    
    var fileName = "Basin_" + index;
    
    Export.table.toAsset({
      collection: bufferedTransects, 
      description: fileName, 
      assetId: wdNorthA + "Transects/"
        + "SelectedHybas4Basins_closedForestsLowerSlopeValley_nonForestedUpperSlope/"
        + "CenterLines/"
        + fileName
    });
  }
}

