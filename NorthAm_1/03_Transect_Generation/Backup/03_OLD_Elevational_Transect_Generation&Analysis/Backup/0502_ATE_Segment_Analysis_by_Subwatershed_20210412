/**
 * Introduction (the following operations are carried out by subwatershed):
 * 1) Extract the coordinates of pixels over the optimal ATEI threshold
 *  along each transect center line in each year.
 * 2) Group each set of the adjacent extracted pixels into one ATE segment 
 *  through a buffering operation.
 * 3) Select transect center lines with only one segment for each year.
 * 4) Create the variables of interest for all the generated annual segments.
 * 5) Calculate the annual sums of the ATEI and the ATEI-weighted elevation
 *  within each annual segment.
 * 
 * Update: 4/15/2021.
 * 
 * Runtime: .
*/


/* Data preparation. */

// Set the 10-km buffered bounding box of the study domain.
var AOI = ee.Geometry.Rectangle({
  coords: [-180, 7.114761500193937, -52.095625030545534, 80.24342770493531],
  geodesic: false
});

// A target projection system.
var targetPrj = {
  crs: "EPSG:4326", 
  scale: 30
};

// Set the working directory.
var wdNA = "users/treeline/NorthAmerica_GME/";

// Load the transect center lines.
var centerLines = ee.FeatureCollection(wdNA + 
  "Transect_Analysis/" + 
  "TransectCL_withID_20210405");
  // .limit(20) // Testing.

// print("centerLines:", centerLines.first(), // With ID.
//   centerLines.size()) // 703172.

// Load the previously selected hydrobasin subwatersheds.
var subwatersheds = ee.FeatureCollection(wdNA + 
  "Transect_Analysis/" + 
  "Hybas12Basins_LowerClosedForests_UpperNonForested_30mSegmentedNewCATE");
  // .limit(20) // Testing.

print("subwatersheds:", 
  // subwatersheds.first(),
  subwatersheds.size())

// Function to print the image information.
function printImgInfo(name, image) {
  print(name,
    image.bandTypes(),
    image.projection().crs(),
    image.projection().nominalScale());
}

// Annual ATEIs based on the annual maximum NDVIs (cloud masked and biome involved).
var annualATEI = ee.Image(wdNA +
  "ATEI_Estimation/AnnualATEI_1984to2020_Biomes356_medianSmdAnnualMaxNDVI_meanSmdElv_newCATE_AOI");

// printImgInfo("annualATEI:", annualATEI)

// ALOS elevation (Version 3.2, released in January 2021) in the AOI.
var ALOSelv = ee.ImageCollection('JAXA/ALOS/AW3D30/V3_2').select('DSM')
  .filterBounds(AOI)
  .mosaic()
  .reproject(targetPrj);

// printImgInfo("ALOSelv:", ALOSelv)


/* Create an ATEI mask over the optimal threshold. */

// An optimal ATEI threshold with the highest Youden Index 
//  of the validation dataset (over 1000 samples).
var threshold = 0.4329;

// Create an ATEI mask over the threshold.
var ATEImask = annualATEI.gt(threshold);

// printImgInfo("ATEImask:", ATEImask)

// Generate an image of coordinates with the target projection.
var coords = ee.Image.pixelLonLat()
  .reproject(targetPrj);

// printImgInfo("coords:", coords)


/* Weight the elevation with the annual ATEIs. */

// Calculate the annual ATEI-weighted elevation.
var ATEIwtd_Elv = annualATEI.multiply(ALOSelv);

// printImgInfo("ATEIwtd_Elv:", ATEIwtd_Elv)


/* Function definitions. */

// Function to generate annual ATE segments along each center line.
var ptBuf = 30; // Equals to the pixel size.

function generateSegments(CL) {
  // Extract the coordinate lists of pixels over the threshold.
  var longList = ee.List(CL.get("longitude"));
  var latList = ee.List(CL.get("latitude"));
  
  var longLat = longList.zip(latList);
  
  // Total number of the extracted pixels.
  var pxCount = longLat.size();
  
  // Create an ATE segment for each set of the adjacent extracted pixels.
  var segments = ee.Geometry.MultiPoint(longLat)
    .buffer(ptBuf)
    .intersection(CL.geometry());
  
  // Get the geometry type of the ATE segments.
  var segType = segments.type();
  
  // Copy and set the variables of interest.
  segments = ee.Feature(segments).copyProperties({
    source: CL, 
    exclude: ["latitude", "longitude"] // List-typed properties can not be exported to the Asset.
  }).set({
    pxCount: pxCount,
    segType: segType
  });
  
  return segments;
}

// Function to rename the annual ATEI-weighted elevation.
function renameWtdElv(currentYear, previousResult) {
  // Convert the year to a String.
  var yearString = ee.String(ee.Number(currentYear).int());
  
  // Rename the ATEI-weighted elevation.
  var oldName = ee.String("ATEI_").cat(yearString);
  var newName = ee.String("wtdElv").cat(yearString);
  var renamedBand = ATEIwtd_Elv.select([oldName], [newName]);
  
  // Append the renamed band to the previous image.
  var combinedImg = ee.Image(previousResult).addBands(renamedBand);
  
  return combinedImg;
}

// Function to buffer the annual ATE segments.
var segBuf = 45; // Equals to 1.5 pixels.

function bufferATEseg(ATEseg) {
  return ATEseg.buffer(segBuf);
}


/* Generate the ATE segments and calculate the variable sums by year. */

var yearList = ee.List.sequence(1984, 2020);

// Rename the annual ATEI-weighted elevation and append the result to the ATEI image.
var ATEIwtdElv_ATEI = ee.Image(yearList.iterate({
  function: renameWtdElv, 
  first: annualATEI
}));

// printImgInfo("ATEIwtdElv_ATEI:", ATEIwtdElv_ATEI)

// Create the annual ATE segments with the sums of variables.
var ATEsegments = yearList.map(function(year) {
  // Extract the qualified pixel coordinates in each year.
  var yearString = ee.String(ee.Number(year).int());
  var annualATEImask = ATEImask.select(ee.String("ATEI_").cat(yearString));
  var annuallyMaskedCoords = coords.updateMask(annualATEImask);
  
  
  /* Carry out the ATE segment analysis by subwatershed. */
  
  var annualATEsegments = subwatersheds.map(function segmentAnalysisBySubwatershed(SWS) {
    // Acquire center lines within each subwatershed.
    var SWSgeom = SWS.geometry();
    var CLs = centerLines.filterBounds(SWSgeom);
    
    // Extract the annual qualified pixel coordinates along each selected center line.
    var annualCLcoords = annuallyMaskedCoords.reduceRegions({
      collection: CLs, 
      reducer: ee.Reducer.toList(), 
      scale: 30,
      crs: "EPSG:4326"
    });
    
    // Remove center lines with no qualified pixel.
    annualCLcoords = annualCLcoords.filter(ee.Filter.and(
      ee.Filter.neq("longitude", []),
      ee.Filter.neq("latitude", [])
    ));
    
    // Generate annual ATE segments along each center line.
    var generatedSegs = annualCLcoords.map(generateSegments);
    
    // Remove center lines with multiple ATE segments in one year 
    //  (The geometry type should NOT be "MultiLineString").
    var selectedSegs = generatedSegs.filter(ee.Filter.eq("segType", "LineString"));
    
    // Generate the variables of interest for each selected ATE segment.
    var annualSegs = selectedSegs.map(function generateVOIs(seg) {
      // Get the length of the annual ATE segment.
      var ATEsegLen = seg.length();
      
      // Extract the coordinates of segment end points.
      var segCoords = seg.geometry().coordinates();
      
      var endPt1 = ee.List(segCoords.get(0));
      var endPt2 = ee.List(segCoords.get(1));
      
      var endPt1Long = endPt1.get(0);
      var endPt1Lat = endPt1.get(1);
      
      var endPt2Long = endPt2.get(0);
      var endPt2Lat = endPt2.get(1);
      
      // Set the variables of interest.
      var ATEseg = seg.set({
        ATEsegLen: ATEsegLen,
        
        endPt1Long: endPt1Long,
        endPt1Lat: endPt1Lat,
        
        endPt2Long: endPt2Long,
        endPt2Lat: endPt2Lat,
        
        Year: year
      });
      
      return ATEseg;
    });
    
    // Select and rename the ATEI and the ATEI-weighted elevation in the same year.
    var ATEIname = ee.String("ATEI_").cat(yearString);
    var wtdElvName = ee.String("wtdElv").cat(yearString);
    var annualVars = ATEIwtdElv_ATEI.select([ATEIname, wtdElvName],
      ["ATEIsum", "wtdElvSum"]);
    
    // Buffer each annual ATE segment.
    var annualBufSegs = annualSegs.map(bufferATEseg);
    
    // Sum the annual variables within each buffered segment.
    var annualVarSum = annualVars.reduceRegions({
      collection: annualBufSegs, 
      reducer: ee.Reducer.sum(), 
      scale: 30, 
      crs: "EPSG:4326"
    });
    
    return annualVarSum;
  });
  
  // Flatten the FeatureCollection to Features.
  return annualATEsegments.flatten();
});

// Convert the result to a FeatureCollection.
ATEsegments = ee.FeatureCollection(ATEsegments).flatten();

// print("ATEsegments:", ATEsegments.limit(10),
//   ATEsegments.size(),
//   ATEsegments.first())


if (false) {
  // Visualize the result.
  Map.setOptions("HYBRID");
  Map.centerObject(ATEsegments.first(), 15);
  
  Map.addLayer(annualATEI.select("ATEI_1984"), {palette: "0000FF, FFFFFF, FF0000"},
    "ATEI_1984", true, 0.5);
  Map.addLayer(centerLines, {color: "00FF00"}, "centerLines");
  Map.addLayer(ee.Feature(ATEsegments.first()), {color: "FFFF00"}, "ATEsegments");

} else if (true) {
  // Output the result to the Asset.
  // var fileName = segBuf + "mBufferedAnnualSegments_ATEIgtPt4329_weightedElvSum_Testing" // Testing.
  var fileName = segBuf + "mBufferedAnnualSegments_ATEIgtPt4329_weightedElvSum";
  
  Export.table.toAsset({
    collection: ATEsegments, 
    description: fileName, 
    assetId: wdNA + 
      "Transect_Analysis/" + 
      fileName
  });
  
} else if (false) {
  // Output the result to the Drive.
  // var fileName = segBuf + "mBufferedAnnualSegments_ATEIgtPt4329_weightedElvSum_Testing" // Testing.
  var fileName = segBuf + "mBufferedAnnualSegments_ATEIgtPt4329_weightedElvSum";
  
  Export.table.toDrive({
    collection: ATEsegments, 
    description: "AnnualATEsegments_WeightedElvSum", 
    folder: fileName, 
    fileFormat: "SHP"
  });
}

